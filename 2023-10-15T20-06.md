#article #python #aiocache #fuckup

Всем привет!  
  
Хочу поделиться своим факапом при работе с `aiocache`  
  
TL;DR  
Обращайте внимание на то, как у вас будет создаваться ключ кэша во избежание   
коллизий  
https://github.com/aio-libs/aiocache/blob/master/aiocache/decorators.py#L111  
(в зависимости от используемой вами версии код может отличаться)  
  
Всех заинтересовавшихся прошу в тред :slight_smile:
  
-----  
  
Я заюзал библиотеку для кэширования асинхронных проперти кастомного класса.  
  
Класс использовался для составления отчётов. Т.е. принимал в конструкторе  
объект, по которому надо было составить отчёт и имел метод для генерации отчёта  
  
Код выглядел примерно так  
```python  
class MyClass:  
    @property
    @aiocache.cached(ttl=60)
	async def my_property(self):
		...  
```  
  
Похожая реализация была в других местах проекта и я особо не задумывался о том,  
как оно работает.  
  
Немного настораживало то, что мы явно задаём `ttl` для кэша, т.е. он не будет  
привязан к объекту класса, но реализация не предполагала, что мы будем  
создавать одинаковые объекты. Т.е. типичный сценарий: создали объект, с его  
помощью сформировали отчёт и больше к этому отчёту не возвращаемся.  
  
Казалось, что самое страшное что произойдёт в этой ситуации -- это то, что мы  
создадим объект класса, для него будет создан кэш, но объект класса "отживёт"  
своё максимум за пару секунд, а кэш будет висеть в памяти целых 60 секунд. Но  
с этим мы были готовы жить.  
  
В один непрекрасный день я обратил внимание на то, что некоторые отчёты совсем  
не соответствуют действительности  
  
Просмотрев реализацию понял, что ошибка скорее всего происходит из-за промахов  
кэша (т.е. когда мы пытаемся получить данные, которые закэшировали для одного  
объекта, но получаем данные другого объекта)  
  
Заглянув в реализацию декоратора увидел то, что  
[дефолтная реализация ключа кэша](https://github.com/aio-libs/aiocache/blob/master/aiocache/decorators.py#L143)  
для кэширования позиционных аргументов оборачивает в строку кортеж с ними.  
  
Напомню, что дефолтная реализация `__str__` для кортежа использует реализацию  
`__repr__` для каждого элемента кортежа.  
  
Я в своём классе не переопределял этот метод, а значит у меня он отдавал строку  
вида  
```  
<MyClass object at 0x107d51a90>  
```  
Где в конце находится шестнадцатеричное представление значения `id(my_obj)`  
  
Казалось бы, что может пойти не так? `id` питоновского объекта должен быть  
уникален...  
  
Но тут следует обратить внимание на контекст использования моего класса.  
  
У меня есть джоба, в которой я итерируюсь по всем объектам, по которым нужно  
сгенерить отчёт, и на каждой итерации инстанцируется объект-сборщик отчёта.  
  
Соответственно после каждой итерации объект-сборщик "умирал". А питон  
[гарантирует уникальность `id` объекта только на протяжении его жизни](https://docs.python.org/3.7/library/functions.html#id)  
  
То есть после "смерти" объекта может быть создан новый объект, `id` которого  
будет совпадать с `id` почившего.  
  
А теперь вспомним, что кэш связанный с объектом не "умирает" вместе с объектом,  
а живёт столько сколько указано в параметре `ttl`  
  
Получается, что в ситуации, когда будет создан объект-сборщик, `id` которого  
совпадает с `id` какого-то предыдущего объекта-сборщика, который был создан  
менее 60 секунд назад, то новый объект вместо создания своего кэша начнёт  
использовать кэш предыдущего объекта!   
  
Собственно, дальше можно устранять сложившуюся ситуацию несколькими способами.  
  
Лично я для себя выбрал подход, который на мой взгляд, максимально лишён  
каких-либо сюрпризов, а именно -- хранить кэшированные значения внутри  
объекта-сборщика. Так наш кэш гарантированно "умрёт" вместе с объектом, а даже  
если в одно и то же время будут существовать два эквивалентных  
объекта-сборщика, то у каждого будет свой кэш и вычисляться эти кэши будут  
независимо друг от друга.  
  
Само решение представляет собой вот такой декоратор:  
```python
def async_cached_property(coro):
    @property
    @functools.wraps(coro)
    async def wrapper(self):
        cached_attr = f'_cached_{coro.__name__}'

        try:
            result = getattr(self, cached_attr)
        except AttributeError:
            result = await coro(self)
            setattr(self, cached_attr, result)

        return result

    return wrapper
```  
  
Всем спасибо за внимание и поменьше вам факапов :blush: